package DataStructures.tree.avl;

/**
 * The interface for an DataStructures.tree.avl.AVL DataStructures.tree.
 * DO NOT EDIT THIS FILE!
 *
 * @author CS 1332 TAs
 * @version 1.0
 */
public interface AVLInterface<T extends Comparable<? super T>> {
    /**
     * Add the data as a leaf to the DataStructures.tree.avl.AVL. Should traverse the DataStructures.tree to find the
     * appropriate location. If the data is already in the DataStructures.tree, then nothing
     * should be done (the duplicate shouldn't get added, and size should not be
     * incremented).
     *
     * Remember to recalculate heights going up the DataStructures.tree, rebalancing if
     * necessary.
     *
     * @throws java.lang.IllegalArgumentException if the data is null
     * @param data the data to be added
     */
    void add(T data);

    /**
     * Removes the data from the DataStructures.tree. There are 3 cases to consider:
     * 1: the data is a leaf. In this case, simply remove it.
     * 2: the data has one child. In this case, simply replace the node with
     * the child node.
     * 3: the data has 2 children. For this assignment, use the successor to
     * replace the data you are removing, not the predecessor.
     *
     * Remember to recalculate heights going up the DataStructures.tree, rebalancing if
     * necessary.
     *
     * @throws java.lang.IllegalArgumentException if the data is null
     * @throws java.util.NoSuchElementException if the data is not in the DataStructures.tree
     * @param data data to remove from the DataStructures.tree
     * @return the data removed from the DataStructures.tree.  Do not return the same data
     * that was passed in.  Return the data that was stored in the DataStructures.tree.
     */
    T remove(T data);

    /**
     * Returns the data in the DataStructures.tree matching the parameter passed in.
     *
     * @throws java.lang.IllegalArgumentException if the data is null
     * @throws java.util.NoSuchElementException if the data is not found
     * @param data data to get in the DataStructures.tree.avl.AVL DataStructures.tree
     * @return the data in the DataStructures.tree equal to the parameter.  Do not return the
     * same data that was passed in.  Return the data that was stored in the
     * DataStructures.tree.
     */
    T get(T data);

    /**
     * Returns whether or not the parameter is contained within the DataStructures.tree.
     *
     * @throws java.lang.IllegalArgumentException if the data is null
     * @param data data to find in the DataStructures.tree.avl.AVL DataStructures.tree
     * @return whether or not the parameter is contained within the DataStructures.tree
     */
    boolean contains(T data);

    /**
     * Get the number of elements in the DataStructures.tree.
     *
     * @return the number of elements in the DataStructures.tree
     */
    int size();

    /**
     * Retrieves the second largest data from the DataStructures.tree.
     *
     * @throws java.util.NoSuchElementException if there isn't enough data in
     * the DataStructures.tree for there to be a second largest element
     * @return the second largest data in the DataStructures.tree
     */
    T getSecondLargest();

    /**
     * Determines whether this DataStructures.tree is equal to the passed in object.
     *
     * Two trees are considered equal if they are equivalent structurally
     * with equal data being in the same locations in each (use value equality).
     *
     * Do not consider the stored heights and balance factors in your equality
     * check, only the structure and the location of the data.
     *
     * Remember, the .equals() method from the Object class takes in an Object,
     * not an DataStructures.tree.avl.AVL object. So, once you've verified that the passed in object
     * is indeed an instance of DataStructures.tree.avl.AVL, you need to cast it to type DataStructures.tree.avl.AVL. If the
     * passed in object is not an DataStructures.tree.avl.AVL, then return false. Keep in mind that if
     * it's an DataStructures.tree.avl.AVL instance, you can access the root directly; do not use
     * the getRoot() method.
     *
     * You may not use anything implementing java.util.List or equivalent to
     * store the data for later use.
     *
     * Ordinarily, you would override the hashCode method as well, but you
     * shouldn't do so for this assignment.
     *
     * @param obj the object we are checking equality with
     * @return true if the trees are equal, false otherwise
     */
    boolean equals(Object obj);

    /**
     * Clear the DataStructures.tree.
     */
    void clear();

    /**
     * Return the height of the root of the DataStructures.tree.
     * 
     * This method does not need to traverse the DataStructures.tree since this is an DataStructures.tree.avl.AVL.
     *
     * @return the height of the root of the DataStructures.tree, -1 if the DataStructures.tree is empty
     */
    int height();
    
    /**
     * THIS METHOD IS ONLY FOR TESTING PURPOSES.
     * DO NOT USE IT IN YOUR CODE
     * DO NOT CHANGE THIS METHOD
     *
     * @return the root of the DataStructures.tree
     */
    AVLNode<T> getRoot();
}
